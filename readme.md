Задание 1.

На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет 
аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы 
обеих реализаций. 
 
                Python example: 
 
                def isEven(value):return value%2==0
   
Вариант 1. (isEvenBitsAND) Реализован через битовое "и", он не сложен и незначительно, но быстрее.
Вариант 2. (isEvenBitsSHIFT) Реализован через побитовый сдвиг. Показывает худшую скорость из трех 
           вариантов, поскольку в своей реализации использует несколько операций. Длиннее.
Вариант 3. (isEvenExample). Пример из условия. Использует функцию деления, что медленнее битовых операций. 
           Самый простой.
   

Задание 2.

На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить 
плюсы и минусы каждой реализации. 

Вариант 1. (CycleBuffer) Класс создан по принципу односвязного списка, требует меньших затрат памяти 
при создании буфера. У каждого элемента есть информация о последующем предыдущем элементе, но невозможно 
обратиться к элементу в середине буфера при необходимости. Немного сложнее в реализации.
Вариант 2. (CycleStorage) Класс основан на списке, что дает простоту реализации, но при создании 
экземпляра память выделяется не соответственно количеству элементов, а с запасом. Есть возможность
обратиться к любому элементу списка по индексу.

Задание 3. 

На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует 
данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и 
отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.

Неоднозначное задание. Без какой-либо информации о массиве выбрать тип сортировки сложно. Проще 
всего стандартный TimSort, но не уверен, что это в тестовом задании предпочтительнее. Выбрал Быструю 
сортировку, поскольку в сгенерированных случайным образом списках она показала стабильное время и при 
росте количества элементов скорость сортировки отсортированного списка повышается плавно. Есть у нее 
недостатки, так в в худшем случае время выполнения может достигать n^2, но это маловероятно. Для 
определения эффективности я спользовал замеры процессорного времени, которое является суммой системного 
и пользовательского.
